		       Simple Expression Parser
		       Mysterious Assignment 2B

		Released: Wed Mar  5 15:47:17 UTC 2014
		  Due: Wed Mar  5 15:47:50 UTC 2014



OVERVIEW

The first task all compilers must handle is converting a program
written in a text file into a data structure that can be processed in
memory. To simplify the job we typically separate this process into a
lexical analyzer and parser. The lexical analyzer (or scanner) is
responsible for translating the characters representing the program in
the text file into a stream of tokens. The parser consumes these
tokens and constructs an abstract syntax tree (AST). The AST is a
tree-like data structure that can be analyzed and/or transformed by
later phases of compilation. In this assignment we are concerned with
implementing the parser for a simple expression language. The parser
will use the provided scanner to build an AST for simple
expressions. Once an AST has been constructed we will implement two
final phases of this simple expression compiler: (1) expr_print, which
will print the input expression to standard output, and (2)
expr_interpret, which will interpret (or evaluate) the simple
expression to compute the result of the expression.


  `---------'      /=====\	      /=====\
  | simple  |      |  s  |   tokens   |  p  |   AST
  |  expr   | ---> |  c  | ---------> |  a  | ------> expr_print
  |  file   |      |  a  | 	      |	 r  | \
  `---------'	   |  n	 |	      |  s  |  \----> expr_interpret
  		   |  n	 |	      |  e  |
		   |  e  |	      |  r  |
		   |  r	 |	      |	    |
		   \=====/	      \=====/

		   Figure 1: Program Structure

FILES

We provide a "starter kit" that will help guide you in your
implementation. Here is a brief description of the contents of this
project:

  README.txt		 :  This file.
  Makefile	         :  A Makefile for building your parser.
  grammar-term.txt	 :  The grammar for term expressions.
  grammar.txt		 :  The grammar for term/factor expressions.
  src/expr-scanner.[h/c] :  The scanner interface and implementation
          		    files for generating tokens from a simple
          		    expression contained in a file.
  src/expr-ast.[h/c]     :  The AST interface and implementation
  			    files. It defines a data structure
  			    representation of the AST for simple
  			    expressions and prototypes for functions
  			    that operate over that AST structure.
  src/expr-parser.[h/c]  :  The parser interface and
  			    implementation. It will use the scanner to
  			    read tokens and construct an AST.
  src/main.c	     	 :  The main entry point into the program.
  expr-parser-soln       :  The parser executable generated by our
  		            solution.

BUILDING

To compile the starter kit you can execute the following command from
the shell:

  vagrant> make

This will produce object files (.o) for each of the main components
and link to produce a final executable: `expr-parser`. You can invoke
the program from the command line:

  usage: expr-parser FILE

To remove all the files created during compilation (e.g., .o,
expr-parser) you run this command:

  vagrant> make clean

DETAILS

The parser is structured into three important modules: *lexer*, *ast*,
and *parser*. In this assignment you should focus your attention
toward the *ast* and *parser* modules. You will also want to look at
`main.c` to get an understanding of how the program begins executing
and how it interacts with the components. You can see what the output
looks like by running our solution parser:

  vagrant> expr-parser-soln test/test_07.txt
  expr = (((3+4)*(2+3))/(5*1))
  7

As you can see it first prints out the AST that is constructed
followed by the result of evaluating the expression.

AST

The AST interface is defined in the `expr-ast.h` header file. It
provides definitions of each of the important nodes found in an
abstract syntax tree for simple expressions: Int, Term, Factor, and
Expr. The Expr struct is used to represent an expression that can
either be an Int, Term, or Factor. In C, we can accomplish this by
using a union along with a "type" to indicate which object the Expr
object points to. The expr_type enum does exactly this by defining the
symbolic constants INT, TERM, FACTOR. Thus, to create an expression
that represents a Term we would write the following C code:

  Expr e;
  e.term = malloc(sizeof(Term));
  e.t = TERM;

Why do we do this? In the days before object-oriented languages and
inheritance we still needed to operate on values of different types -
yet belonging to the same category. In our case, we have Int, Factor,
and Term, all of which are an Expr, but have potentially different
implementations. In modern object-oriented languages we would simply
create a base class or interface called Expr and extend it with each
of the corresponding types (Int, Term, Factor). C accomplishes this
with the union and type identifier.

The AST module also provides prototype (interface) definitions for
creating each of the important expressions as well as the functions
for printing an expression and interpreting an expression:

  int expr_print(Expr* expr);
  int expr_interpret(Expr* expr);

expr_print takes an Expr* as its argument. It will print the AST to
stdout in the same format as it was read in from the text file. The
only difference is that expr_print will also add a '(' and ')' around
each expression in the AST. For example, in test/test_02.txt we have
the expression:

  4*5+2*3+4*6*7;

expr_print will produce the following to standard output:

  ((4*5)+((2*3)+(4*(6*7))))

As you can see each of the sub-expressions have been wrapped in
parenthesis. This makes it clear that you are constructing the AST
properly. This function returns 1 if the expression was printed
successfully; false otherwise.

expr_interpret takes an Expr* as its argument. It will evaluate the
expression and return the resulting value. Thus, it will recursively
visit the nodes in the AST evaluating each in turn. Note, that this is
a bottom-up process. We must first evaluate the leaves, then the
internal nodes of the tree. For example, given the simple expression
1*2+3*4 we would have the AST:

    +
  /   \
 *     *
/ \   / \ 
1 2   3 4

We would first need to evaluate the leaves - which are Int nodes. This
is easy because the Int nodes evaluate to themselves. We then evaluate
the '*' operators:

    +
  /   \
 2    12

We would then evaluate the '+' operator:

    +
  /   \     =>     14
 2    12

We can define the rules of evaluation recursively as we do in the
following rules:

expr_interpret(e) => return e.value, if e is an Int
expr_interpret(e) => return expr_interpret(e.left) +
		            expr_interpret(e.right),
	             if e is a term whose operator is +
expr_interpret(e) => return expr_interpret(e.left) -
		            expr_interpret(e.right),
	             if e is a term whose operator is -
expr_interpret(e) => return expr_interpret(e.left) *
		            expr_interpret(e.right),
	             if e is a factor whose operator is *
expr_interpret(e) => return expr_interpret(e.left) /
		            expr_interpret(e.right),
	             if e is a factor whose operator is /
expr_interpret(e) => print "failure" if e is NULL

PARSER
-- TODO --

ASSIGNMENT

Your job is to complete the following:

 AST
  (1) Complete the implementation of the AST definitions by including
      a Factor abstraction. You should follow the implementation of
      the Term adding any additional definitions to other
      enumerations, structs, etc.
  (2) Implement the expr_print function in expr-ast.c.
  (3) Implement the expr_interpret function in expr-ast.c

 Parser
  (1) Complete the implementation of the parser. The parser you are
      given successfully parses expression terms, but needs to be
      extended to support factors. You should consult the
      `grammar.txt` file to see the grammar that the parser is
      using. You should not deviate from this grammar
      definition. Use the provided term implementation as a guide to
      adding factors.
